# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Achievement {
  claimed: Boolean!
  id: Int!
  transaction: JSON
  type: AchievementType!
  wallet: String!
}

"""An identifier for the type of achievement."""
enum AchievementType {
  BETA_TUTORIAL_COMPLETED
  TUTORIAL_COMPLETED
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type GoldBucket {
  accrued: Int!
  createdAt: DateTime!
  paid: Int!
  updatedAt: DateTime!
  userId: ID!
  withdrawalTransaction: TransactionInfo
  withdrawalTransactionAmount: Int
  withdrawalTransactionSignature: String
}

type GoldReceiptLineItem {
  id: GoldReceiptLineItemId!
  total: Int!
}

enum GoldReceiptLineItemId {
  COINS
  GUILDIE_BONUS_GOLD
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

enum LootBoxId {
  BAKER_BABA
}

type LootBoxReward {
  createdAt: DateTime!
  id: String!
  inputTransactionSignature: String!
  lootBoxId: LootBoxId!
  rewardIndex: Int!
  rewardTransactionSignature: String
  updatedAt: DateTime!
  userId: ID!
}

type Mutation {
  connectWallet(claim: String!, signature: String!, signer: String!): String
  createLootBoxReward(blockHash: String!, lootBoxId: LootBoxId!, mints: [String!], signature: String!, userId: ID!): LootBoxReward!
  createTokenDispenserAllocation(amount: Float!, paymentTokenAccount: String!, tokenAccount: String!, tokenDispenserId: TokenDispenserId!, user: String!): TokenDispenserAllocation!
  createWithdrawGoldTransaction(feePayer: String, userId: ID!): GoldBucket!
  mintAchievement(type: AchievementType!, wallet: String!): Achievement!
  processTokenDispenserAllocationTransaction(signature: String!, tokenDispenserId: TokenDispenserId!, user: String!): TokenDispenserAllocation
  processWithdrawGoldTransaction(signature: String!, userId: ID!): GoldBucket!
  requestBetaTutorialCompletedAchievement(goldenKeyMint: String!, wallet: String!): Achievement!
  setGameCompleted(endGameState: StoryGameLevelGameState!, gameCoins: StoryGameCoinsInput, gameId: ID!): SetGameCompletedResult!
  startNewGame(levelId: StoryGameLevelIdentifier!): StoryGameLevel!
}

type Query {
  achievement(type: AchievementType!, wallet: String!): Achievement
  goldBucket(userId: ID!): GoldBucket
  guildiesCollection(userId: ID!): UserGuildieCollectionAggregate
  newTemporaryToken: String!
  nonce: Float!
  storyGameProgress(userId: ID!): StoryGameProgress
  tokenDispenser(id: TokenDispenserId!): TokenDispenser
  tokenDispenserQuote(amount: Float!, id: TokenDispenserId!): Float!
  tokenSwapConfig(id: TokenSwapId!): TokenSwapConfig!
  tokenSwapTransaction(tokenSwapId: TokenSwapId!, user: String!): SignedTransactionInfo!
  user(id: ID!): User
}

type SetGameCompletedResult {
  achievementsUnlocked: [String!]!
  goldReceipt: [GoldReceiptLineItem!]!
  levelsUnlocked: [String!]!
  storyGameLevel: StoryGameLevel!
  totalGoldRewarded: Int!
}

type SignedTransactionInfo {
  signature: String!
  transaction: TransactionInfo!
}

input StoryGameCoinsInput {
  coins: Int!
  duration: Int!
}

type StoryGameLevel {
  coins: Int
  completedAt: DateTime
  createdAt: DateTime!
  duration: Int
  gameState: StoryGameLevelGameState!
  guildieBonusGoldFactor: Float!
  id: ID!
  levelId: StoryGameLevelIdentifier!
  updatedAt: DateTime!
  userId: ID!
}

"""The end state of the game level."""
enum StoryGameLevelGameState {
  ACTIVE
  LOSE
  WIN
}

"""The game level"""
enum StoryGameLevelIdentifier {
  DUNGEON
  FOREST
  SEWER
  TUTORIAL
}

type StoryGameProgress {
  createdAt: DateTime!
  furthestLevelCompleted: StoryGameLevelIdentifier!
  id: ID!
  updatedAt: DateTime!
  userId: ID!
}

type TokenDispenser {
  content: Int!
  createdAt: DateTime!
  currentPrice: Float!
  id: TokenDispenserId!
  paymentMint: String!
  paymentType: TokenDispenserPaymentType!
  supply: Int!
  tokenMint: String!
  totalSupply: Int!
  updatedAt: DateTime!
}

type TokenDispenserAllocation {
  createdAt: DateTime!
  id: ID!
  paymentAmount: Float!
  tokenAmount: Float!
  tokenDispenserId: TokenDispenserId!
  transaction: TransactionInfo
  transactionSignature: String
  updatedAt: DateTime!
}

"""The token dispenser identifier"""
enum TokenDispenserId {
  BURN_GOLD_FOR_PIXEL
}

"""The token dispenser payment type"""
enum TokenDispenserPaymentType {
  BURN
}

type TokenSwapConfig {
  input: TokenSwapConfigInput!
  output: TokenSwapConfigOutput!
}

type TokenSwapConfigInput {
  amount: Int!
  creator: String
  method: TokenSwapInputMethod!
  mint: String
}

type TokenSwapConfigOutput {
  amount: Int!
  mint: String!
}

"""The token swap id"""
enum TokenSwapId {
  PIXEL_FOR_LOOTCHEST
}

"""The token dispenser input method"""
enum TokenSwapInputMethod {
  TRANSFER
}

type TransactionInfo {
  blockHash: String!
  data: String!
  lastValidBlockHeight: Int!
}

type User {
  createdAt: DateTime!
  id: ID!
  solCredit: Float!
  solCreditLatestSignature: String
  updatedAt: DateTime!
  wallet: String
}

type UserGuildieCollectionAggregate {
  userId: ID!
}
